<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Memory Miner — Prototype</title>
<style>
:root{
  --bg:#050608;
  --panel:#0b0f13;
  --accent:#00e6ff;
  --accent2:#8a00ff;
  --danger:#ff4d6d;
  --glass: rgba(255,255,255,0.04);
  font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
}
html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg),#071018);color:#dbe9ef}
.app{max-width:980px;margin:18px auto;padding:18px;}
.header{display:flex;align-items:center;gap:12px;margin-bottom:12px}
.logo{width:56px;height:56px;border-radius:12px;background:linear-gradient(135deg,var(--accent),var(--accent2));display:flex;align-items:center;justify-content:center;font-weight:700;color:#021;box-shadow:0 8px 24px rgba(0,0,0,0.6)}
.title{font-size:20px;font-weight:700}
.controls{margin-left:auto;display:flex;gap:8px;align-items:center}
.hud{display:flex;gap:10px;align-items:center;background:var(--glass);padding:10px;border-radius:10px}
.hud .stat{font-size:13px}
.grid{display:grid;grid-template-columns:repeat(6,1fr);gap:8px;background:transparent;padding:12px;border-radius:12px}
.tile{background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));height:78px;border-radius:8px;display:flex;align-items:center;justify-content:center;font-weight:700;color:#9fdff7;cursor:pointer;user-select:none;position:relative;box-shadow:inset 0 1px 0 rgba(255,255,255,0.02)}
.tile.revealed{background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));cursor:default}
.tile .inner{opacity:0;transition:all .2s}
.tile.revealed .inner{opacity:1}
.footer{margin-top:12px;display:flex;gap:8px;align-items:center;justify-content:space-between}
.modal{position:fixed;inset:0;background:linear-gradient(0deg,rgba(2,4,6,0.6),rgba(2,4,6,0.6));display:none;align-items:center;justify-content:center;z-index:40}
.modal.show{display:flex}
.card{background:linear-gradient(180deg,#071018,#0b1620);padding:18px;border-radius:12px;min-width:320px;max-width:720px;box-shadow:0 10px 40px rgba(2,6,10,0.6);color:#e6f7ff}
.btn{background:var(--accent);border:none;padding:8px 12px;border-radius:8px;color:#021;font-weight:700;cursor:pointer}
.btn.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:#cfeffb}
.small{font-size:13px;color:#a9cbd6}
.shop{display:flex;gap:8px}
.level{font-weight:700}
.progress{height:10px;background:rgba(255,255,255,0.03);border-radius:999px;overflow:hidden}
.progress > i{display:block;height:100%;background:linear-gradient(90deg,var(--accent),var(--accent2));width:0%}
.notice{padding:8px;border-radius:8px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));font-size:13px}
.pulse{animation:pulse 1.6s linear infinite}
@keyframes pulse{0%{transform:scale(1)}50%{transform:scale(1.02)}100%{transform:scale(1)}}
.toprow{display:flex;gap:8px;align-items:center}
.brandsmall{font-size:12px;color:#88d9ef}
.footer small{opacity:0.7}
</style>
</head>
<body>
<div class="app">
  <div class="header">
    <div class="logo">MM</div>
    <div>
      <div class="title">Memory Miner — Prototype</div>
      <div class="brandsmall">Tap to mine memory tiles, collect fragments, avoid corruption.</div>
    </div>
    <div class="controls">
      <div class="hud">
        <div class="stat">Level: <span id="level">1</span></div>
        <div class="stat">Fragments: <span id="fragments">0</span>/<span id="needed">6</span></div>
        <div class="stat">Health: <span id="health">5</span></div>
      </div>
    </div>
  </div>

  <div class="notice">Tip: Collect fragments to unlock a Core Memory puzzle. Corruption reduces health. Reach deeper layers to earn higher rewards.</div>

  <div id="grid" class="grid" style="margin-top:12px;"></div>

  <div class="footer">
    <div style="display:flex;gap:8px;align-items:center">
      <div class="level small">Depth: <span id="depth">1</span></div>
      <div style="width:220px">
        <div class="progress" aria-hidden="true"><i id="progressBar" style="width:0%"></i></div>
      </div>
    </div>
    <div>
      <button class="btn" id="restartBtn">Restart Level</button>
      <button class="btn ghost" id="shopBtn">Shop</button>
    </div>
  </div>
</div>

<!-- Modal for core memory puzzle -->
<div id="modal" class="modal">
  <div class="card" id="modalCard">
    <div id="modalContent"></div>
  </div>
</div>

<script>
/* Memory Miner Prototype JS
 - Grid of tiles. Each tile hides: fragment, corruption, empty, or chest.
 - Collect fragments; when enough collected -> trigger core puzzle (Simon-like)
 - Simple progression, health, depth, scoring
*/

const config = {
  cols: 6,
  rows: 4,
  tilesPerLevel: 24,
  startHealth: 5,
  fragmentsNeededBase: 6
};

let state = {
  level: 1,
  depth: 1,
  health: config.startHealth,
  fragments: 0,
  fragmentsNeeded: config.fragmentsNeededBase,
  progress: 0,
  grid: [],
  awaitingPuzzle: false
};

const gridEl = document.getElementById('grid');
const levelEl = document.getElementById('level');
const fragmentsEl = document.getElementById('fragments');
const neededEl = document.getElementById('needed');
const healthEl = document.getElementById('health');
const depthEl = document.getElementById('depth');
const progressBar = document.getElementById('progressBar');
const modal = document.getElementById('modal');
const modalContent = document.getElementById('modalContent');

function rnd(n){ return Math.floor(Math.random()*n) }

function newLevel(){
  state.fragmentsNeeded = config.fragmentsNeededBase + Math.floor(state.depth/2);
  state.fragments = 0;
  state.progress = 0;
  state.health = Math.max(1, state.health); // keep current health
  state.grid = [];
  levelEl.textContent = state.level;
  fragmentsEl.textContent = state.fragments;
  neededEl.textContent = state.fragmentsNeeded;
  healthEl.textContent = state.health;
  depthEl.textContent = state.depth;
  progressBar.style.width = (state.progress)+'%';
  buildGrid();
}

function buildGrid(){
  gridEl.innerHTML = '';
  gridEl.style.gridTemplateColumns = `repeat(${config.cols}, 1fr)`;
  const total = config.cols * config.rows;
  // distribution: fragments ~ fragmentsNeeded, corruption ~ 4, chest ~1, rest empty
  let items = [];
  for(let i=0;i<state.fragmentsNeeded;i++) items.push('fragment');
  for(let i=0;i<Math.min(4,total-items.length);i++) items.push('corruption');
  items.push('chest');
  while(items.length < total) items.push('empty');
  // shuffle
  items = items.sort(()=>Math.random()-0.5);
  for(let i=0;i<total;i++){
    const kind = items[i];
    const tile = makeTile(kind, i);
    gridEl.appendChild(tile);
    state.grid.push({kind, revealed:false, el:tile});
  }
}

function makeTile(kind, idx){
  const t = document.createElement('div');
  t.className = 'tile';
  t.dataset.idx = idx;
  const inner = document.createElement('div');
  inner.className = 'inner';
  inner.style.fontSize = '14px';
  if(kind==='fragment') inner.textContent = '🔹';
  else if(kind==='corruption') inner.textContent = '☠️';
  else if(kind==='chest') inner.textContent = '📦';
  else inner.textContent = '';
  t.appendChild(inner);
  t.addEventListener('click', ()=>onTileClick(idx));
  return t;
}

function onTileClick(i){
  const cell = state.grid[i];
  if(!cell || cell.revealed || state.awaitingPuzzle) return;
  cell.revealed = true;
  cell.el.classList.add('revealed');
  const inner = cell.el.querySelector('.inner');
  inner.style.opacity = 1;
  // small animation
  cell.el.animate([{transform:'scale(0.98)'},{transform:'scale(1)'}],{duration:160});
  if(cell.kind==='fragment'){
    state.fragments++;
    fragmentsEl.textContent = state.fragments;
    playSound('collect');
    if(state.fragments >= state.fragmentsNeeded){
      // unlock core memory
      state.awaitingPuzzle = true;
      setTimeout(()=>openCorePuzzle(), 600);
    }
  } else if(cell.kind==='corruption'){
    state.health--;
    healthEl.textContent = state.health;
    playSound('hurt');
    if(state.health <= 0){
      gameOver();
      return;
    }
  } else if(cell.kind==='chest'){
    // reward: heal or fragments
    const r = Math.random();
    if(r < 0.5){
      state.health++;
      healthEl.textContent = state.health;
      toast('Restored 1 Health');
    } else {
      state.fragments++;
      fragmentsEl.textContent = state.fragments;
      toast('Found 1 Fragment');
      if(state.fragments >= state.fragmentsNeeded){
        state.awaitingPuzzle = true;
        setTimeout(()=>openCorePuzzle(), 600);
      }
    }
  } else {
    // empty
  }
  // progress increments slightly per reveal
  state.progress = Math.min(100, state.progress + (100/config.tilesPerLevel));
  progressBar.style.width = state.progress+'%';
}

function openCorePuzzle(){
  showModal();
  modalContent.innerHTML = '';
  const card = document.createElement('div');
  card.innerHTML = `<h3 style="margin:0 0 8px 0">Core Memory — Reconstruct the Sequence</h3>
    <div class="small">Watch the sequence, then repeat it. Succeed to unlock the memory and go deeper.</div>
    <div id="puzzleArea" style="margin-top:12px"></div>
    <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px">
      <button class="btn ghost" id="skipBtn">Skip (-1 Health)</button>
    </div>`;
  modalContent.appendChild(card);
  const puzzleArea = document.getElementById('puzzleArea');
  startSimonLike(puzzleArea);
  document.getElementById('skipBtn').onclick = ()=>{ state.health--; healthEl.textContent=state.health; closeModal(); state.awaitingPuzzle=false; if(state.health<=0) gameOver(); }
}

function showModal(){ modal.classList.add('show'); }
function closeModal(){ modal.classList.remove('show'); modalContent.innerHTML=''; }

function startSimonLike(container){
  // create 3x3 pad
  const size=3;
  const pad = document.createElement('div');
  pad.style.display='grid';
  pad.style.gridTemplateColumns=`repeat(${size},60px)`;
  pad.style.gap='8px';
  pad.style.justifyContent='center';
  const buttons = [];
  for(let i=0;i<size*size;i++){
    const b = document.createElement('div');
    b.style.width='60px'; b.style.height='60px';
    b.style.borderRadius='8px';
    b.style.display='flex'; b.style.alignItems='center'; b.style.justifyContent='center';
    b.style.background='linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01))';
    b.style.fontWeight='700';
    b.style.cursor='pointer';
    b.textContent = '';
    pad.appendChild(b); buttons.push(b);
  }
  container.appendChild(pad);
  // generate sequence length based on depth
  const seqLen = Math.min(8,3 + Math.floor(state.depth/2));
  const seq = [];
  for(let i=0;i<seqLen;i++) seq.push(Math.floor(Math.random()*buttons.length));
  // show sequence
  let i=0;
  playSequence(seq, buttons, ()=>{
    // allow player to input
    let pos=0;
    buttons.forEach((b, idx)=>{
      b.onclick = ()=>{
        flashButton(b);
        if(idx === seq[pos]){
          pos++;
          if(pos === seq.length){
            // success
            onPuzzleSuccess();
            buttons.forEach(x=>x.onclick=null);
          }
        } else {
          // fail
          onPuzzleFail();
          buttons.forEach(x=>x.onclick=null);
        }
      };
    });
  });

  function playSequence(seq, buttons, cb){
    let j=0;
    const iv = setInterval(()=>{
      const idx = seq[j];
      flashButton(buttons[idx]);
      j++;
      if(j>=seq.length){ clearInterval(iv); setTimeout(cb,400); }
    },700);
  }

  function flashButton(b){
    b.animate([{transform:'scale(1)'},{transform:'scale(1.08)'},{transform:'scale(1)'}],{duration:280});
    // slight glow
    const prev = b.style.boxShadow;
    b.style.boxShadow = '0 8px 30px rgba(0,230,255,0.15)';
    setTimeout(()=> b.style.boxShadow = prev,320);
    playSound('beep');
  }
}

function onPuzzleSuccess(){
  toast('Core Memory Reconstructed! Depth +1');
  playSound('win');
  // reward: level up depth, keep health, add bonus fragments
  state.depth++;
  state.level++;
  state.fragments = 0;
  state.progress = 0;
  closeModal();
  state.awaitingPuzzle = false;
  newLevel();
}

function onPuzzleFail(){
  toast('Failed — Corruption seizes a memory. -1 Health');
  playSound('fail');
  state.health--;
  healthEl.textContent = state.health;
  closeModal();
  state.awaitingPuzzle = false;
  if(state.health <= 0) gameOver();
}

function gameOver(){
  showModal();
  modalContent.innerHTML = `<div class="card"><h2 style="margin:0">Memory Collapse</h2>
    <p class="small">Your miner's health reached zero. Depth reached: ${state.depth}. You can restart the level.</p>
    <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px">
      <button class="btn" id="tryAgain">Restart From Depth 1</button>
    </div></div>`;
  document.getElementById('tryAgain').onclick = ()=>{
    state.depth = 1;
    state.level = 1;
    state.health = config.startHealth;
    state.fragments = 0;
    state.awaitingPuzzle = false;
    closeModal();
    newLevel();
  };
}

function toast(msg){
  const d = document.createElement('div');
  d.className='notice';
  d.style.position='fixed';
  d.style.right='18px';
  d.style.bottom='18px';
  d.style.zIndex=60;
  d.textContent = msg;
  document.body.appendChild(d);
  setTimeout(()=> d.style.opacity=0,1600);
  setTimeout(()=> d.remove(),2200);
}

// Basic sounds using WebAudio
let audioCtx = null;
function ensureAudio(){
  if(audioCtx) return;
  audioCtx = new (window.AudioContext||window.webkitAudioContext)();
}
function playSound(name){
  ensureAudio();
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.connect(g); g.connect(audioCtx.destination);
  if(name==='beep'){ o.frequency.value = 900; g.gain.value=0.03; o.start(); setTimeout(()=>o.stop(),120); }
  else if(name==='collect'){ o.frequency.value = 600; g.gain.value=0.04; o.start(); setTimeout(()=>o.stop(),220); }
  else if(name==='hurt'){ o.frequency.value = 220; g.gain.value=0.06; o.start(); setTimeout(()=>o.stop(),350); }
  else if(name==='win'){ o.frequency.value = 1200; g.gain.value=0.06; o.start(); setTimeout(()=>o.stop(),360); }
  else if(name==='fail'){ o.frequency.value = 140; g.gain.value=0.06; o.start(); setTimeout(()=>o.stop(),360); }
}

// Buttons
document.getElementById('restartBtn').onclick = ()=>{
  state.fragments = 0;
  state.progress = 0;
  state.health = config.startHealth;
  state.awaitingPuzzle = false;
  newLevel();
};
document.getElementById('shopBtn').onclick = ()=> openShop();

function openShop(){
  showModal();
  modalContent.innerHTML = `<div class="card">
    <h3 style="margin:0">Workshop (Prototype)</h3>
    <div class="small" style="margin-top:6px">Buy upgrades (prototype placeholders). This area is where IAPs or ad rewards would connect in a full build.</div>
    <div style="display:flex;gap:8px;margin-top:12px">
      <div style="flex:1">
        <div class="notice">Corruption Shield<br/><small class="small">One-time: prevents 1 corruption tile this level</small></div>
      </div>
      <div style="display:flex;flex-direction:column;gap:6px;align-items:flex-end;justify-content:center">
        <button class="btn ghost" id="buyShield">Buy (demo)</button>
      </div>
    </div>
    <div style="display:flex;justify-content:flex-end;margin-top:12px"><button class="btn" id="closeShop">Close</button></div>
  </div>`;
  document.getElementById('closeShop').onclick = ()=> closeModal();
  document.getElementById('buyShield').onclick = ()=>{
    toast('Purchased (demo). In a full build this would consume currency or open a purchase.');
  };
}

// initial setup
newLevel();
</script>
</body>
</html>
